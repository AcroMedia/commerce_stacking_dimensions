<?php

/**
 * @file
 * Declares the paths for the UI and holds all functions.
 */

/**
 * Implements hook_menu().
 */
function commerce_stacking_dimensions_menu() {
  $items = array();

  $items['admin/commerce/config/stacking'] = array(
    'title' => 'Stacking Products',
    'description' => 'Choose product types to enable a stacking mode during
                      dimension calculations.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_stacking_dimensions_form'),
    'access arguments' => array('configure store'),
  );

  return $items;
}

/**
 * Returns the form for editing the product types that can be stacked.
 *
 * @param array $form
 *   A form object.
 * @param array $form_state
 *   The updated object if loaded after being submitted.
 *
 * @return mixed
 *   Returns the final form structure.
 */
function commerce_stacking_dimensions_form($form, &$form_state) {

  $form['description'] = array(
    '#markup' => '<p>' . t('Choose product types to add dimension fields to that
                          track how multiple products, when stacked, change
                          their dimension.') . '</p>',
  );

  // Load product types and simplify.
  $product_types = commerce_product_types();
  foreach ($product_types as $id => $type) {
    $product_types[$id] = $type['name'];
  }

  $form['commerce_stacking_dimensions_product_types'] = array(
    '#type' => 'checkboxes',
    '#title' => 'Product Types',
    '#options' => $product_types,
    '#default_value' => variable_get('commerce_stacking_dimensions_product_types', array()),
    '#description' => '<br><hr><br><em>'.t('WARNING: Unchecking a particular product type and 
                         saving the changes <strong>WILL</strong> remove the stacking dimension
                         fields and data. This is your only warning.').'</em>',
  );

  $form['submit_button'] = array(
    '#type' => 'submit',
    '#value' => t('Save Changes'),
  );

  return $form;
}

/**
 * Implements hook_form_submit().
 */
function commerce_stacking_dimensions_form_submit($form, &$form_state) {
  $old = variable_get('commerce_stacking_dimensions_product_types', array());
  $new = array_filter($form_state['values']['commerce_stacking_dimensions_product_types']);
  variable_set('commerce_stacking_dimensions_product_types', $new);

  // Delete field instances that are attached to old and not in new.
  $remove = array_diff($old, $new);
  if ($remove) {
    foreach ($remove as $bundle) {
      $instance = field_info_instance('commerce_product', 'stacking_dimensions', $bundle);
      field_delete_instance($instance, FALSE);
    }
    drupal_set_message(format_plural(count($remove),"The stacking dimension field on @bundles was removed.",
      "The stacking dimension field on the following @count bundles were removed: @bundles",array('@bundles' => implode(", ", $remove))), 'status');
  }

  // Add field instances to new and not in old.
  $add = array_diff($new, $old);
  if ($add) {
    foreach ($add as $bundle) {
      field_create_instance(array(
        "label" => "Stacking Dimensions",
        "field_name" => "stacking_dimensions",
        "entity_type" => "commerce_product",
        "bundle" => $bundle,
      ));
    }
    drupal_set_message(format_plural(count($add),"@bundles now has a stacking dimension field.",
      "A new stacking dimension field was added to these @count bundles: @bundles",array('@bundles' => implode(", ", $add))), 'status');
  }
}

/**
 * Implements hook_commerce_physical_order_volume_alter().
 */
function commerce_stacking_dimensions_commerce_physical_order_volume_alter(&$volume, $order, $unit) {
  // Skip our reset if there is no volume.
  if ($volume === NULL) {
    return;
  }

  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $volume = NULL;

  // Loop over each line item on the order.
  foreach ($order_wrapper->commerce_line_items as $line_item_wrapper) {
    // Get the dimensions value of product line items.
    if (in_array($line_item_wrapper->type->value(), commerce_product_line_item_types())) {
      $line_item_dimensions = commerce_physical_product_line_item_dimensions($line_item_wrapper->value());

      // Add it to the running total converting it to the required weight unit.
      if (!physical_field_is_empty($line_item_dimensions, array('type' => 'physical_dimensions'))) {
        $converted_dimensions = physical_dimensions_convert($line_item_dimensions, $unit);
        $quantity = $line_item_wrapper->quantity->value();

        // Step 1: Determine if more than one, possible stacking line item.
        if (round($quantity, 0) > 1) {
          // Step 2: Determine if product type has stacking dimensions field.
          if (array_key_exists("stacking_dimensions", $line_item_wrapper->commerce_product->getPropertyInfo())) {
            // Step 3: Review dimensions that change per quantity.
            $stacking_dimensions = $line_item_wrapper->commerce_product->stacking_dimensions->value();
            $reset_quantity = FALSE;
            foreach (array_keys($converted_dimensions) as $type) {
              // Step 4: Modify each dimension by quantity.
              if ($type != "unit" && round($stacking_dimensions[$type], 0) > 0) {
                // Skip zeros, exclude original dimension from multiplication.
                $converted_dimensions[$type] = $converted_dimensions[$type] + ($stacking_dimensions[$type] * ($quantity - 1));

                // Reset quantity only if a stacking dimension was set.
                $reset_quantity = TRUE;
              }
            }
            // Reset the quantity because the quantity has already been used.
            if ($reset_quantity) {
              $quantity = 1;
            }
          }
        }

        $converted_dimensions['volume'] = $converted_dimensions['width'] * $converted_dimensions['length'] * $converted_dimensions['height'] * $quantity;

        if (empty($volume['volume'])) {
          // Create a volume value array using the converted unit type.
          $volume = array(
            'volume' => $converted_dimensions['volume'],
            'unit' => $unit,
          );
        }
        else {
          $volume['volume'] += $converted_dimensions['volume'];
        }
      }
    }
    // No return needed, &$volume is going to be returned by the original hook.
  }
}
